<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Game "Killer Cell"</title>
</head>

<body>
  <canvas id="game"></canvas>

  <style>
    html {
      overflow: hidden;
    }

    body {
      margin: 0pt;
    }
  </style>

  <script>

    class WorldSearcher {
      constructor(objects) {
        this.objects = objects
      }
      findClosest(pos, prefilter) {
        return this.objects
          .filter(object => prefilter(object))
          .reduce(
            (closest, object) => {
              const objectDistance = WorldPos.distanse(object.pos, pos)
              if (closest == null) {
                return {
                  'distance': objectDistance,
                  'object': object
                }
              }
              if (objectDistance < closest.distance) {
                return {
                  'distance': objectDistance,
                  'object': object
                }
              }
              return closest;
            },
            null
          )
      }
      findAllAtDistance(pos, distance, prefilter) {
        return this.objects
          .filter(object => prefilter(object))
          .filter(object => {
            const objectDistance = WorldPos.distanse(object.pos, pos)
            return objectDistance < distance
          })
      }
    }

    class WorldDrawer {
      constructor(ctx, canvasWidth, canvasHeight) {
        this.ctx = ctx
        this.canvasWidth = canvasWidth
        this.canvasHeight = canvasHeight
        this.objectDrawers = {}
        this.objectDrawers[Food.name] = new FoodDrawer()
        this.objectDrawers[HerbivoreCell.name] = new HerbivoreCellDrawer()
        this.objectDrawers[CarnivorousCell.name] = new CarnivorousCellDrawer()
      }
      draw(world) {
        this.clear()
        world.objects.forEach(object => {
          const canvasCoordinate = this.mapWorldPosToCanvasCoordinate(object.pos)
          const objectDrawer = this.objectDrawers[object.constructor.name]
          objectDrawer.draw(object, this.ctx, canvasCoordinate)
        })
      }
      clear() {
        this.ctx.fillStyle = '#82eaff'
        this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight)
      }
      mapWorldPosToCanvasCoordinate(pos) {
        return new CanvasCoordinate(pos.x, this.canvasHeight - pos.y)
      }
    }

    class WorldObjectDrawer {
      draw(object, ctx, coordinate) {
      }
    }

    class World {
      constructor(width, height, objects) {
        this.objects = objects
        this.searcher = new WorldSearcher(objects)
        this.width = width
        this.height = height
      }
      update() {
        this.searcher = new WorldSearcher(this.objects)
        this.objects.forEach(object => {
          object.update(this)
        })
        for (let i = 0; i < this.objects.length; i++) {
          const object = this.objects[i]
          if (object && object instanceof Cell) {
            const cell = object
            var eatenCells = this.searcher.findAllAtDistance(object.pos, 5, (it) => cell.canEat(it))
            this.objects = this.objects.filter(it => !eatenCells.includes(it))
          }
        }
      }
    }

    class CanvasCoordinate {
      constructor(x, y) {
        this.x = x
        this.y = y
      }
    }

    class WorldPos {
      constructor(x, y) {
        this.x = x
        this.y = y
      }
      static distanse(pos1, pos2) {
        return Math.hypot(Math.abs(pos1.x - pos2.x), Math.abs(pos1.y - pos2.y))
      }
    }

    class WorldObject {
      constructor(pos) {
        this.pos = pos
      }
      update(world) {
      }
    }

    class Food extends WorldObject {
      update(world) {
      }
    }

    class FoodDrawer extends WorldObjectDrawer {
      draw(object, ctx, coordinate) {
        ctx.beginPath()
        ctx.arc(coordinate.x, coordinate.y, 5, 0, 2 * Math.PI, false)
        ctx.fillStyle = 'yellow'
        ctx.fill()
      }
    }

    class Cell extends WorldObject {
      constructor(pos, moveDistance = 5) {
        super(pos)
        this.moveDistance = moveDistance
      }
      update(world) {
        const closestFood = this.findClosestFood(world)?.object
        if (closestFood) {
          const vectorToClosestFood = [closestFood.pos.x - this.pos.x, closestFood.pos.y - this.pos.y]
          this.pos.x = this.pos.x + this.moveDistance * this.cos(vectorToClosestFood)
          this.pos.y = this.pos.y + this.moveDistance * this.sin(vectorToClosestFood)
        }
      }
      cos(vector) {
        const ax = vector[0]
        const ay = vector[1]
        const bx = 1
        const by = 0
        return (ax * bx + ay * by) / (Math.sqrt(ax ** 2 + ay ** 2) * Math.sqrt(bx ** 2 + by ** 2))
      }
      sin(vector) {
        const cos = this.cos(vector)
        if (vector[1] < 0) {
          return -Math.sqrt(1 - cos ** 2)
        }
        return Math.sqrt(1 - cos ** 2)
      }
    }

    class HerbivoreCell extends Cell {
      findClosestFood(world) {
        return world.searcher.findClosest(this.pos, object => object instanceof Food)
      }
      canEat(object) {
        return object instanceof Food
      }
    }

    class HerbivoreCellDrawer extends WorldObjectDrawer {
      draw(object, ctx, coordinate) {
        ctx.beginPath()
        ctx.arc(coordinate.x, coordinate.y, 10, 0, 2 * Math.PI, false)
        ctx.fillStyle = 'green'
        ctx.fill()
      }
    }

    class CarnivorousCell extends Cell {
      findClosestFood(world) {
        return world.searcher.findClosest(this.pos, object => object != this && object instanceof Cell)
      }
      canEat(object) {
        return object != this && object instanceof Cell
      }
    }

    class CarnivorousCellDrawer extends WorldObjectDrawer {
      draw(object, ctx, coordinate) {
        ctx.beginPath()
        ctx.arc(coordinate.x, coordinate.y, 10, 0, 2 * Math.PI, false)
        ctx.fillStyle = 'red'
        ctx.fill()
      }
    }

    class WorldObjectGenerator {
      constructor(width, height) {
        this.numberOfCells = 50
        this.numberOfFood = 100
        this.killerCellProbability = 0.5
        this.width = width
        this.height = height
      }
      generate() {
        const objects = []
        for (let i = 0; i < this.numberOfCells; i++) {
          const pos = new WorldPos(Math.random() * this.width, Math.random() * this.height)
          if (Math.random() < this.killerCellProbability) {
            objects.push(new CarnivorousCell(pos))
          } else {
            objects.push(new HerbivoreCell(pos))
          }
        }
        for (let i = 0; i < this.numberOfFood; i++) {
          const pos = new WorldPos(Math.random() * this.width, Math.random() * this.height)
          objects.push(new Food(pos))
        }
        return objects
      }
    }

    class Game {
      constructor() {
        this.updateInterval = 1000 / 60
        const canvas = document.getElementById('game')
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        const ctx = canvas.getContext('2d')
        const worldObjectGenerator = new WorldObjectGenerator(canvas.width, canvas.height)
        this.world = new World(
          canvas.width,
          canvas.height,
          worldObjectGenerator.generate()
        )
        this.worldDrawer = new WorldDrawer(ctx, canvas.width, canvas.height)
      }

      start() {
        setInterval(() => {
          this.world.update()
          this.worldDrawer.draw(this.world)
        }, this.updateInterval)
      }

    }

    const game = new Game()
    game.start()
  </script>
</body>

</html>